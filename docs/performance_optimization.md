# パフォーマンス最適化

このドキュメントでは、アプリケーションに実装されたパフォーマンス最適化について説明します。

## 実装済みの最適化

### 1. React Query によるデータキャッシュ

**実装内容**:
- `@tanstack/react-query` を導入
- サーバー状態管理とキャッシュ機能を提供
- 自動的なバックグラウンド再取得

**キャッシュ設定**:
```typescript
{
  staleTime: 1000 * 60 * 5,  // 5分間データを新鮮と見なす
  gcTime: 1000 * 60 * 10,     // 10分間キャッシュを保持
  refetchOnWindowFocus: false, // ウィンドウフォーカス時の再取得を無効化
  retry: 1                     // 失敗時1回リトライ
}
```

**適用箇所**:
- ダッシュボードページ (`src/app/page.tsx`)
  - `dashboardSummary`: 総商品数、ASIN紐付け率、利益統計
  - `shopStats`: ショップ別統計
- 割引設定ページ (`src/app/settings/discounts/page.tsx`)
  - `discounts`: 割引設定一覧
  - ミューテーション: 作成、削除、有効/無効切り替え

**メリット**:
- 同じデータへの重複リクエストを防止
- ページ間移動時のデータ再利用
- 楽観的UI更新による高速なレスポンス

### 2. ページネーション

**実装内容**:
- 商品テーブルにページネーション実装
- デフォルト50件/ページ（カスタマイズ可能）

**適用箇所**:
- `PaginatedProductTable` コンポーネント

**メリット**:
- 大量データでも初回レンダリングが高速
- メモリ使用量の削減
- スクロールパフォーマンスの向上

### 3. Next.js Image 最適化

**実装内容**:
- `next/image` コンポーネント使用
- 自動的な画像最適化とWebP変換
- 遅延ロード対応

**適用箇所**:
- 商品テーブル内の商品画像

**メリット**:
- 画像サイズの自動最適化
- レスポンシブ画像配信
- Cumulative Layout Shift (CLS) の防止

### 4. useMemo と useCallback

**実装内容**:
- 計算コストの高い処理を `useMemo` でメモ化
- コールバック関数を `useCallback` でメモ化

**適用箇所**:
- 商品テーブルのフィルタリング・ソート処理
- イベントハンドラー

**メリット**:
- 不要な再計算を防止
- 再レンダリングの削減

## 今後の最適化候補

### 1. テーブル仮想化

**検討内容**:
- `@tanstack/react-virtual` の導入
- 表示領域のみレンダリング

**期待効果**:
- 数万件のデータでもスムーズなスクロール
- メモリ使用量の大幅削減

**実装優先度**: 中（データ量が増えた場合）

### 2. コード分割

**検討内容**:
- Dynamic Import の活用
- ルート単位での分割

**期待効果**:
- 初回ロード時間の短縮
- 必要なコードのみダウンロード

**実装優先度**: 低

### 3. データベースクエリ最適化

**検討内容**:
- インデックスの追加
- N+1問題の解消
- 集計クエリの最適化

**期待効果**:
- API レスポンス時間の短縮
- データベース負荷の軽減

**実装優先度**: 中

## パフォーマンス計測

### 推奨ツール

1. **React DevTools Profiler**
   - コンポーネントのレンダリングパフォーマンスを計測

2. **Chrome DevTools Performance**
   - JavaScript実行時間、レンダリング時間を分析

3. **Lighthouse**
   - 総合的なパフォーマンススコア測定

### 計測指標

- **LCP (Largest Contentful Paint)**: 2.5秒以下を目標
- **FID (First Input Delay)**: 100ms以下を目標
- **CLS (Cumulative Layout Shift)**: 0.1以下を目標
- **TTI (Time to Interactive)**: 3.5秒以下を目標

## ベストプラクティス

### 1. データ取得

- React Query を使用してキャッシュを活用
- 並列リクエストは `Promise.all()` でまとめる
- 不要なデータ取得は避ける

### 2. レンダリング

- `useMemo` で計算コストの高い処理をメモ化
- `useCallback` でコールバック関数をメモ化
- リストレンダリングには安定した `key` を使用

### 3. 画像

- Next.js Image コンポーネントを使用
- 適切な `width` と `height` を指定
- `priority` プロパティで重要な画像を優先ロード

### 4. バンドルサイズ

- 不要なライブラリのインポートを避ける
- Tree-shaking を活用
- Dynamic Import で遅延ロード
